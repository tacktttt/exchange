// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for OrderPosition.
const (
	BUY  OrderPosition = "BUY"
	SELL OrderPosition = "SELL"
)

// Currency defines model for currency.
type Currency struct {
	Id     string `json:"id"`
	Symbol string `json:"symbol"`
}

// Order defines model for order.
type Order struct {
	Id               string    `json:"id"`
	KeyAmount        int       `json:"keyAmount"`
	Pair             Pair      `json:"pair"`
	SettlementAmount int       `json:"settlementAmount"`
	UtcCreatedAt     time.Time `json:"utcCreatedAt"`
}

// order position enum
type OrderPosition string

// Pair defines model for pair.
type Pair struct {
	Id                 string   `json:"id"`
	KeyCurrency        Currency `json:"keyCurrency"`
	SettlementCurrency Currency `json:"settlementCurrency"`
}

// User defines model for user.
type User struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// Wallet defines model for wallet.
type Wallet struct {
	Amount   int      `json:"amount"`
	Currency Currency `json:"currency"`
	Id       string   `json:"id"`
}

// OrderId defines model for orderId.
type OrderId = string

// PairId defines model for pairId.
type PairId = string

// UserId defines model for userId.
type UserId = string

// WalletId defines model for walletId.
type WalletId = string

// GetOrder defines model for getOrder.
type GetOrder struct {
	Id *Order `json:"id,omitempty"`
}

// GetOrders defines model for getOrders.
type GetOrders struct {
	Id *[]Order `json:"id,omitempty"`
}

// GetPair defines model for getPair.
type GetPair = Pair

// GetPairs defines model for getPairs.
type GetPairs = []Pair

// GetUser defines model for getUser.
type GetUser = User

// GetWallet defines model for getWallet.
type GetWallet = Wallet

// GetWallets defines model for getWallets.
type GetWallets = []Wallet

// CreateOrder defines model for createOrder.
type CreateOrder struct {
	KeyAmount int  `json:"key_amount"`
	Pair      Pair `json:"pair"`

	// order position enum
	Position         OrderPosition `json:"position"`
	SettlementAmount int           `json:"settlement_amount"`
}

// CreatePairOrderJSONRequestBody defines body for CreatePairOrder for application/json ContentType.
type CreatePairOrderJSONRequestBody CreateOrder

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// delete pair order
	// (DELETE /orders/{orderId})
	DeletePairOrder(ctx echo.Context, orderId OrderId) error
	// get order
	// (GET /orders/{orderId})
	GetPairOrder(ctx echo.Context, orderId OrderId) error
	// get pairs
	// (GET /pairs)
	GetPairs(ctx echo.Context) error
	// get pair
	// (GET /pairs/{pairId})
	GetPair(ctx echo.Context, pairId PairId) error
	// get pair orders
	// (GET /pairs/{pairId}/orders)
	GetPairOrders(ctx echo.Context, pairId PairId) error
	// create pair order
	// (POST /pairs/{pairId}/orders)
	CreatePairOrder(ctx echo.Context, pairId PairId) error
	// get user
	// (GET /users/{userId})
	GetUser(ctx echo.Context, userId UserId) error
	// get user wallets
	// (GET /users/{userId}/wallets)
	GetUserWallets(ctx echo.Context, userId UserId) error
	// get user wallet
	// (GET /users/{userId}/wallets/{walletId})
	GetUserWallet(ctx echo.Context, userId UserId, walletId WalletId) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DeletePairOrder converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePairOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId OrderId

	err = runtime.BindStyledParameterWithLocation("simple", false, "orderId", runtime.ParamLocationPath, ctx.Param("orderId"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePairOrder(ctx, orderId)
	return err
}

// GetPairOrder converts echo context to params.
func (w *ServerInterfaceWrapper) GetPairOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId OrderId

	err = runtime.BindStyledParameterWithLocation("simple", false, "orderId", runtime.ParamLocationPath, ctx.Param("orderId"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPairOrder(ctx, orderId)
	return err
}

// GetPairs converts echo context to params.
func (w *ServerInterfaceWrapper) GetPairs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPairs(ctx)
	return err
}

// GetPair converts echo context to params.
func (w *ServerInterfaceWrapper) GetPair(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pairId" -------------
	var pairId PairId

	err = runtime.BindStyledParameterWithLocation("simple", false, "pairId", runtime.ParamLocationPath, ctx.Param("pairId"), &pairId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pairId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPair(ctx, pairId)
	return err
}

// GetPairOrders converts echo context to params.
func (w *ServerInterfaceWrapper) GetPairOrders(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pairId" -------------
	var pairId PairId

	err = runtime.BindStyledParameterWithLocation("simple", false, "pairId", runtime.ParamLocationPath, ctx.Param("pairId"), &pairId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pairId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPairOrders(ctx, pairId)
	return err
}

// CreatePairOrder converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePairOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pairId" -------------
	var pairId PairId

	err = runtime.BindStyledParameterWithLocation("simple", false, "pairId", runtime.ParamLocationPath, ctx.Param("pairId"), &pairId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pairId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreatePairOrder(ctx, pairId)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, userId)
	return err
}

// GetUserWallets converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserWallets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserWallets(ctx, userId)
	return err
}

// GetUserWallet converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserWallet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// ------------- Path parameter "walletId" -------------
	var walletId WalletId

	err = runtime.BindStyledParameterWithLocation("simple", false, "walletId", runtime.ParamLocationPath, ctx.Param("walletId"), &walletId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserWallet(ctx, userId, walletId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE(baseURL+"/orders/:orderId", wrapper.DeletePairOrder)
	router.GET(baseURL+"/orders/:orderId", wrapper.GetPairOrder)
	router.GET(baseURL+"/pairs", wrapper.GetPairs)
	router.GET(baseURL+"/pairs/:pairId", wrapper.GetPair)
	router.GET(baseURL+"/pairs/:pairId/orders", wrapper.GetPairOrders)
	router.POST(baseURL+"/pairs/:pairId/orders", wrapper.CreatePairOrder)
	router.GET(baseURL+"/users/:userId", wrapper.GetUser)
	router.GET(baseURL+"/users/:userId/wallets", wrapper.GetUserWallets)
	router.GET(baseURL+"/users/:userId/wallets/:walletId", wrapper.GetUserWallet)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/7RY32/bNhD+VwJuj2rkNRua6a3thqFYgQQYgmEIioGRLjZTSWRJKqli6H8vyCNlyaJk",
	"KXaeEktHft9994NHbUnKC8FLKLUiyZYIKmkBGqT9xWUG8lNm/s1ApZIJzXhJEnxxxjISEWZ+C6o3JCIl",
	"LcC//WReSvhWMQkZSbSsICIq3UBBzX66FsZUacnKNWmaiAjKgljm+SiUW7QMqVJhr8zzUSS3aBnSE81z",
	"0CEsfDOK1i5cgtegMSj9gWcMbAhTCVTDlYmI/clLDaU2/1IhcpZSwyd+UIbUtrO3kFyA1G6Xr1D/Twte",
	"4UqHy0oNa5DExc68+VnCPUnIT/Euq2LcU8XWxthyxVCEaXubRdfeuImIAq1zKKDUE1yarmC3XeKhDTps",
	"nBNfIr8lv3uAVKOs/dihpmdYBE7xszue1Q5eCV4qFG4N+ljtWTZLKYt9kPoadMsbaRplPUt1NE2moVAz",
	"+bZ0qZS0Xshf7Ttw7VJwNv3DuRqGt/0oAL5MvFlC+ZLZ02mU1kCUGwWnE8V0wDF02zr3wP+1Pexk8NgS",
	"xwi4fhqk8AqR8WTmxQatu9FpfB9HbpWUUKb1WFXtNfqIqLq443n4zOm2P3u8OGPT2ZjOjXWLN6i4CA/v",
	"2US+Qv3+ROfCrjtP7Vjp9KNtv9l7a3HPZUE1SUhGNbzRrICdU1OiWNQu/wCBPbSOgCjSvnoR+f5GaS5y",
	"tt5oLxr59fJd9Y2+vXh4Es/MkumfbCPDlT+YzqCsChIR+ye5JR9u/iMR+efPz58HhK53Z1lfgTCxQqjy",
	"QtDnx2f+DO0ItiT0Hzt5OxXiNt96YV6+OhTILo3g7h2VXNAHOV+pBSmPE9qsyrOmHXyLE8B/ajtln8HU",
	"yJW+QPugRyHinQbhOHS8cGznZf8TXG7uWEZ//+1dKkx/NDTKe26JuA3he7qh5dpU7iNIhVXwy/nKtiMB",
	"JRWMJOTifHW+spWrN1YdnCNUvHX3jQZLKQcNw6LC53h4W/tzYjeX9hgwEzr5w5qYo/zKlXdvlHu7Wg23",
	"vfobe3lVFFTWIRx3Eg2XtqPMkMlfOFFM0QiFvLWL27GzT66FxN68u+rdhjfcmcT+Ttd8aSJie7afb8Oe",
	"WYtRz9RLvcLFQ69E+xy5xVu8GTYHSY5yPIbiCMPlsrv7bUf11jOX/gcddPPydJapo9JsLCIO+gi37QUt",
	"4Jy7gk2VMx7c/Tryl+N63LfO/TnuXp6bE9bhgD1mrjkeVLzFLw3TmWtsghG9US9vGTcq2DFw7l8aQve9",
	"BDO375mbntVBD/3gPOqpn+9f6LBfHvbZo7+K7/HWf+Jp5spwQIXjRJjWYLkE7QesJlogl50P5aPHqGRO",
	"ErLRWiRxnPOU5huudHK5ulwZ6x8BAAD//3Bll469FAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
